/*Overlaping microtubules.*/

#include "master_header.h"

int main(int argc, char *argv[])
{
	system_parameters parameters;
	microtubule *mt_array, *mt_array_initial;
	char param_file[160];
	int n_runs, length_of_microtubule, n_microtubules, n_steps, data_threshold, range_of_data, pickup_time, equil_milestone;
	double delta_t, duration, p_bind, p_unbind, p_switch, p_move, p_plus, p_minus;
	long seed;
	FILE *f_config, *output_file, *stream; 
	clock_t start, finish;

	// Initializes and sets generator type for RNG
    const gsl_rng_type *generator_type; 
    generator_type = gsl_rng_mt19937;   
    gsl_rng *rng; 

	// Get command-line input.
	if (argc != 4) {
		fprintf(stderr, "Wrong number of command-line arguments in main\n");
		fprintf(stderr, "Usage: %s parameters.yaml initial_mts.config output_file.file\n", argv[0]);
		exit(1);
	}
	start = clock();

	// Read in input parameters. 
	strcpy(param_file, argv[1]);
	parse_parameters(param_file, &parameters);

	// Initialize local variables. 
	n_steps = parameters.n_steps;									// Total number of steps in one run
	data_threshold = parameters.data_threshold;						// Step at which data collection starts 
	delta_t = parameters.delta_t;									// Duration of one step in seconds
	seed = parameters.seed;											// Seed for the RNG
	
	//temporary sloppy decloraiton; FIX FIX FIX
	p_bind = parameters.k_on*parameters.c_motor*parameters.delta_t;
	p_unbind = parameters.k_off*parameters.delta_t;
	p_switch = parameters.switch_rate*parameters.delta_t;
	p_move = 125*parameters.motor_speed*parameters.delta_t;	
	double alpha = parameters.alpha;
	double beta = parameters.beta;
	p_plus = 1 - beta;
	p_minus = alpha;

	range_of_data = n_steps - data_threshold;
	pickup_time = range_of_data/10000;								// We want ~10,000 timepoints to average from
	equil_milestone = data_threshold/20;							// Runs are long so we'd like some update on progress during equilibration

	// Allocates memory for and seeds the RNG	
	rng = gsl_rng_alloc(generator_type);
	gsl_rng_set(rng, seed);
	
	long dummy = 0;
	// 'Warm up' our RNG, as its initial states can be non-random
	for(int i_rng; i_rng < 10000; i_rng++){
		dummy = gsl_rng_get(rng);
	}

	// Read initial state 
	f_config = gfopen(argv[2], "rb");
	fprintf(stdout, "\nReading initial configuration from %s:\n", argv[2]);
	fread(&n_runs, sizeof(int), 1, f_config);
	fread(&n_microtubules, sizeof(int), 1, f_config);
	fread(&length_of_microtubule, sizeof(int), 1, f_config);
	fprintf(stdout, "   n_runs = %d\n", n_runs);
	fprintf(stdout, "   n_microtubules = %d\n", n_microtubules);
	fprintf(stdout, "   length = %d\n\n", length_of_microtubule);

	// Copies variables from config file to parameter file
	parameters.n_microtubules = n_microtubules;
	parameters.length_of_microtubule = length_of_microtubule;
	
	// Outputs parameters in "sim units"  
	printf("Motor velocity: %f sites per timestep\n", parameters.motor_speed*125*delta_t);    // There are 125 sites in one micron (tubulin is ~8nm)
	printf("Motor switching frequency: %f per timestep\n", parameters.switch_rate*delta_t);
	printf("Motor binding frequency: %f per timestep\n", parameters.k_on*parameters.c_motor*delta_t);
	printf("Motor unbinding frequency: %f per timestep\n", parameters.k_off*delta_t);
	printf("Total simulation duration: %f seconds\n", delta_t*n_steps);
	printf("Timestep duration: %f seconds\n\n", delta_t);
	fflush(stdout);

	// Initializes and allocates memory for two MT pointers so that they can mimmick arrays.
	// Data from initial config file (generated by build_mts) populates mt_array_initial,
	// which permanently stores this information and passes it onto mt_array for kMC runs
	mt_array = (microtubule*) malloc(n_microtubules*sizeof(microtubule));
	mt_array_initial = (microtubule*) malloc(n_microtubules*sizeof(microtubule));	
	for (int j_mt = 0; j_mt < n_microtubules; j_mt++){	
		// 'Track' of each MT, i.e. what the motors move along (1 site = 1 tubulin)
		mt_array[j_mt].track = (site*) malloc(length_of_microtubule*sizeof(site));
		mt_array_initial[j_mt].track = (site*) malloc(length_of_microtubule*sizeof(site));
		for(int k_site = 0; k_site < length_of_microtubule; k_site++){
			// Initial occupancy of each site on track (0 means empty and 2 means motor as of now)
			mt_array[j_mt].track[k_site].occupancy = (int*) malloc(sizeof(int));
			mt_array_initial[j_mt].track[k_site].occupancy = (int*) malloc(sizeof(int));
			fread(mt_array_initial[j_mt].track[k_site].occupancy, sizeof(int), 1, f_config);
			// Initial coord (or ID maybe??) distribution of each site on track 			 ***POTENTIALLY UNNECESSARY***
			mt_array[j_mt].track[k_site].coord = (int*) malloc(sizeof(int));
			mt_array_initial[j_mt].track[k_site].coord = (int*) malloc(sizeof(int));
			fread(mt_array_initial[j_mt].track[k_site].coord, sizeof(int), 1, f_config);
		}
		// Polarity of each MT (0 means plus-end is on RIGHT, 1 means plus-end is on LEFT)
		mt_array[j_mt].polarity = (int*) malloc(sizeof(int));
		mt_array_initial[j_mt].polarity = (int*) malloc(sizeof(int));
		fread(mt_array_initial[j_mt].polarity, sizeof(int), 1, f_config);
		// Coordinates of each MT (relative to the left edge, i.e. the 0 index of each array)
		mt_array[j_mt].coord = (int*) malloc(sizeof(int));
		mt_array_initial[j_mt].coord = (int*) malloc(sizeof(int));
		fread(mt_array_initial[j_mt].coord, sizeof(int), 1, f_config);
		// Number of motors bound to each MT 
		mt_array[j_mt].n_bound = (int*) malloc(sizeof(int));
		mt_array_initial[j_mt].n_bound = (int*) malloc(sizeof(int));
		fread(mt_array_initial[j_mt].n_bound, sizeof(int), 1, f_config);
	}
	fclose(f_config);

	// Main simulation loop
	output_file = gfopen(argv[3], "w");
	for(int i_run = 0; i_run < n_runs; i_run++){
		// Copy data from initial mt array
		for(int j_mt = 0; j_mt < n_microtubules; j_mt++){
			memcpy(&mt_array[j_mt], &mt_array_initial[j_mt], sizeof(microtubule));
		}

		// Main kMC loop 
		for(int i_step = 0; i_step < n_steps; i_step++){

			// Store the indices (from 0 to length_of_microtubule - 1) in a list
			std::vector<int> index_list;
			for(int k_site = 0; k_site < length_of_microtubule; k_site++){
				index_list.push_back(k_site);
			}
			// Calculate total number of expected kMC events, i.e how many times to run below loop
			int n_events = n_microtubules*index_list.size();
		
			for(int i_kmc = 0; i_kmc < n_events; i_kmc++){
				// Randomly choose a microtubule
				int mt_index = gsl_rng_uniform_int(rng, n_microtubules);

				int mt_index_adj, delta_x, plus_end, minus_end;
				// Assign the relevant directions depending on polarity of MT
				if(mt_array[mt_index].polarity[0] == 0){
					mt_index_adj = mt_index + 1;
					delta_x = 1;
					plus_end = length_of_microtubule - 1;
					minus_end = 0;
				}
				else if(mt_array[mt_index].polarity[0] == 1){
					mt_index_adj = mt_index - 1;
					delta_x = -1;
					plus_end = 0;
					minus_end = length_of_microtubule - 1;
				}
			
				// Randomly choose a site from the appropriate index list
				int list_size = index_list.size();
				int list_entry = gsl_rng_uniform_int(rng, list_size);
				// Get appropriate index for that site
				int index = index_list[list_entry];
				// Roll the random numbers we'll need for this timestep
				double random1 = gsl_rng_uniform(rng);
				double random2 = gsl_rng_uniform(rng);

				// Check if we're dealing with the boundaries here
				if(index == 0 || index == (length_of_microtubule - 1)){
					// If index is the plus end, nothing interesting can happen; go to BC
					if(index == plus_end){
						goto boundary_conditions;
					}
					// Otherwise, it must be the minus end
					else if(index == minus_end){
						// If site is unoccupied, nothing interesting can happen; go to BC
						if(mt_array[mt_index].track[minus_end].occupancy[0] == 0){
							goto boundary_conditions;
						}
						// Otherwise, check if a motor is at the minus end
						else if(mt_array[mt_index].track[minus_end].occupancy[0] == 2){
							// Check if the motor isn't blocked by something
							if(mt_array[mt_index].track[(minus_end + delta_x)].occupancy[0] == 0){	
								// Attempt to move
								if(random2 < p_move){
									mt_array[mt_index].track[index].occupancy[0] = 0;
									mt_array[mt_index].track[(index + delta_x)].occupancy[0] = 2;
									goto boundary_conditions;
								}	
							}
						}
					}
				}
				// If not at boundaries, go to routine algorithm:
				else{
					// Check if site is unoccupied; if so, attempt to bind:
					if(mt_array[mt_index].track[index].occupancy[0] == 0){
						if(random1 < p_bind){
							mt_array[mt_index].track[index].occupancy[0] = 2;
							mt_array[mt_index].n_bound[0]++;
							goto boundary_conditions;
						}
					}
					// Otherwise, check if motor is bound; if so, attempt to unbind:
					else if(mt_array[mt_index].track[index].occupancy[0] == 2){
						if(random2 < p_unbind){	
							mt_array[mt_index].track[index].occupancy[0] = 0;
							mt_array[mt_index].n_bound[0]--;	
							goto boundary_conditions;
						}
						// Otherwise, roll to see if we should attempt to switch:
						else if(random2 < (p_unbind + p_switch)){ 
							if(mt_array[mt_index_adj].track[index].occupancy[0] == 0){
								mt_array[mt_index].track[index].occupancy[0] = 0;
								mt_array[mt_index].n_bound[0]--;
								mt_array[mt_index_adj].track[index].occupancy[0] = 2;
								mt_array[mt_index_adj].n_bound[0]++;
								goto boundary_conditions;
							}
						}
						// Otherwise, roll to see if we should attempt to move:
						else if(random2 < (p_unbind + p_switch + p_move)){ 
							if(mt_array[mt_index].track[(index + delta_x)].occupancy[0] == 0){
									mt_array[mt_index].track[index].occupancy[0] = 0;
									mt_array[mt_index].track[(index + delta_x)].occupancy[0] = 2;
									goto boundary_conditions;
							}
						}
					}
				}
// Enforce BC after every kmc event in timestep
boundary_conditions:
				for(int j_mt = 0; j_mt < n_microtubules; j_mt++){
					if(mt_array[j_mt].polarity[0] == 0){
            			plus_end = (length_of_microtubule - 1);
            			minus_end = 0;
        			}
        			else if(mt_array[j_mt].polarity[0] == 1){
            			plus_end = 0;
            			minus_end = (length_of_microtubule - 1);
        			}
					double random3 = gsl_rng_uniform(rng);
					double random4 = gsl_rng_uniform(rng);
					// Enforces boundary condition for plus-end
					if(random3 >= p_plus && mt_array[j_mt].track[plus_end].occupancy[0] == 2){ 
						mt_array[j_mt].track[plus_end].occupancy[0] = 0;    
						mt_array[j_mt].n_bound[0]--;
					}
					else if(random3 < p_plus && mt_array[j_mt].track[plus_end].occupancy[0] == 0){ 
						mt_array[j_mt].track[plus_end].occupancy[0] = 2;
						mt_array[j_mt].n_bound[0]++;    
					}
					// Enforces boundary condition for minus-end
					if(random4 >= p_minus && mt_array[j_mt].track[minus_end].occupancy[0] == 2){ 
						mt_array[j_mt].track[minus_end].occupancy[0] = 0;   
						mt_array[j_mt].n_bound[0]--;
					}
					else if(random4 < p_minus && mt_array[j_mt].track[minus_end].occupancy[0] == 0){ 
						mt_array[j_mt].track[minus_end].occupancy[0] = 2;
						mt_array[j_mt].n_bound[0]++;    
					}
				}
			}
//			print_microtubules(&parameters, mt_array);
//			printf("\n");

			// Gives updates on equilibration process (every 5%)
			if(i_step < data_threshold){
				if(i_step%equil_milestone == 0){
					printf("Equilibration is %i percent complete. (step number %i)\n", (int)(i_step/equil_milestone)*5, i_step);
				}
			}
			// Starts data collection at threshold
			else if(i_step >= data_threshold){
				int delta = i_step - data_threshold;
				if(delta%pickup_time == 0){
					printf("\nRun %d, step %d:\n", (i_run+1), (i_step));
					print_microtubules(&parameters, mt_array);
					output_data(&parameters, mt_array, output_file);	
					fflush(stdout);
				}
			}
		}
	}
	fclose(output_file);

	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;

	stream = fopen("time_main.dat","w");
	fprintf(stream, "Time to execute main code: %f seconds\n", duration);
	fclose(stream);

	return 0;
}
