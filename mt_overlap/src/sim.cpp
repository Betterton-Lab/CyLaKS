/*Overlaping microtubules.*/

#include "master_header.h"

int main(int argc, char *argv[])
{
	system_parameters parameters;
	microtubule *mt_array, *mt_array_initial;
	char param_file[160];
	int n_runs, length_of_microtubule, n_microtubules, n_steps, data_threshold, range_of_data, pickup_time, equil_milestone;
	double delta_t, duration, p_bind, p_unbind, p_switch, p_move;
	long seed;
	FILE *f_config, *output_file, *stream; 
	clock_t start, finish;

	// Initializes and sets generator type for RNG
    const gsl_rng_type *generator_type; 
    generator_type = gsl_rng_mt19937;   
    gsl_rng *rng; 

	// Get command-line input.
	if (argc != 4) {
		fprintf(stderr, "Wrong number of command-line arguments in main\n");
		fprintf(stderr, "Usage: %s parameters.yaml initial_mts.config output_file.file\n", argv[0]);
		exit(1);
	}
	start = clock();

	// Read in input parameters. 
	strcpy(param_file, argv[1]);
	parse_parameters(param_file, &parameters);

	// Initialize local variables. 
	n_steps = parameters.n_steps;									// Total number of steps in one run
	data_threshold = parameters.data_threshold;						// Step at which data collection starts 
	delta_t = parameters.delta_t;									// Duration of one step in seconds
	seed = parameters.seed;											// Seed for the RNG
	
	//temporary sloppy decloraiton; FIX FIX FIX
	p_bind = parameters.k_on*parameters.c_motor*parameters.delta_t;
	p_unbind = parameters.k_off*parameters.delta_t;
	p_switch = parameters.switch_rate*parameters.delta_t;
	p_move = 125*parameters.motor_speed*parameters.delta_t;		

	range_of_data = n_steps - data_threshold;
	pickup_time = range_of_data/10000;								// We want ~10,000 timepoints to average from
	equil_milestone = data_threshold/20;							// Runs are long so we'd like some update on progress during equilibration

	// Allocates memory for and seeds the RNG	
	rng = gsl_rng_alloc(generator_type);
	gsl_rng_set(rng, seed);
	
	long dummy = 0;
	// 'Warm up' our RNG, as its initial states can be non-random
	for(int i_rng; i_rng < 10000; i_rng++){
		dummy = gsl_rng_get(rng);
	}

	// Read initial state 
	f_config = gfopen(argv[2], "rb");
	fprintf(stdout, "\nReading initial configuration from %s:\n", argv[2]);
	fread(&n_runs, sizeof(int), 1, f_config);
	fread(&n_microtubules, sizeof(int), 1, f_config);
	fread(&length_of_microtubule, sizeof(int), 1, f_config);
	fprintf(stdout, "   n_runs = %d\n", n_runs);
	fprintf(stdout, "   n_microtubules = %d\n", n_microtubules);
	fprintf(stdout, "   length = %d\n\n", length_of_microtubule);

	// Copies variables from config file to parameter file
	parameters.n_microtubules = n_microtubules;
	parameters.length_of_microtubule = length_of_microtubule;
	
	// Outputs parameters in "sim units"  
	printf("Motor velocity: %f sites per timestep\n", parameters.motor_speed*125*delta_t);    // There are 125 sites in one micron (tubulin is ~8nm)
	printf("Motor switching frequency: %f per timestep\n", parameters.switch_rate*delta_t);
	printf("Motor binding frequency: %f per timestep\n", parameters.k_on*parameters.c_motor*delta_t);
	printf("Motor unbinding frequency: %f per timestep\n", parameters.k_off*delta_t);
	printf("Total simulation duration: %f seconds\n", delta_t*n_steps);
	printf("Timestep duration: %f seconds\n\n", delta_t);
	fflush(stdout);

	// Initializes and allocates memory for two MT pointers so that they can mimmick arrays.
	// Data from initial config file (generated by build_mts) populates mt_array_initial,
	// which permanently stores this information and passes it onto mt_array for kMC runs
	mt_array = (microtubule*) malloc(n_microtubules*sizeof(microtubule));
	mt_array_initial = (microtubule*) malloc(n_microtubules*sizeof(microtubule));	
	for (int j_mt = 0; j_mt < n_microtubules; j_mt++){	
		// 'Track' of each MT, i.e. what the motors move along (1 site = 1 tubulin)
		mt_array[j_mt].track = (site*) malloc(length_of_microtubule*sizeof(site));
		mt_array_initial[j_mt].track = (site*) malloc(length_of_microtubule*sizeof(site));
		for(int k_site = 0; k_site < length_of_microtubule; k_site++){
			// Initial occupancy of each site on track (0 means empty and 2 means motor as of now)
			mt_array[j_mt].track[k_site].occupancy = (int*) malloc(sizeof(int));
			mt_array_initial[j_mt].track[k_site].occupancy = (int*) malloc(sizeof(int));
			fread(mt_array_initial[j_mt].track[k_site].occupancy, sizeof(int), 1, f_config);
			// Initial coord (or ID maybe??) distribution of each site on track 			 ***POTENTIALLY UNNECESSARY***
			mt_array[j_mt].track[k_site].coord = (int*) malloc(sizeof(int));
			mt_array_initial[j_mt].track[k_site].coord = (int*) malloc(sizeof(int));
			fread(mt_array_initial[j_mt].track[k_site].coord, sizeof(int), 1, f_config);
		}
		// Polarity of each MT (0 means plus-end is on RIGHT, 1 means plus-end is on LEFT)
		mt_array[j_mt].polarity = (int*) malloc(sizeof(int));
		mt_array_initial[j_mt].polarity = (int*) malloc(sizeof(int));
		fread(mt_array_initial[j_mt].polarity, sizeof(int), 1, f_config);
		// Coordinates of each MT (relative to the left edge, i.e. the 0 index of each array)
		mt_array[j_mt].coord = (int*) malloc(sizeof(int));
		mt_array_initial[j_mt].coord = (int*) malloc(sizeof(int));
		fread(mt_array_initial[j_mt].coord, sizeof(int), 1, f_config);
		// Number of motors bound to each MT 
		mt_array[j_mt].n_bound = (int*) malloc(sizeof(int));
		mt_array_initial[j_mt].n_bound = (int*) malloc(sizeof(int));
		fread(mt_array_initial[j_mt].n_bound, sizeof(int), 1, f_config);
	}
	fclose(f_config);

	// Main simulation loop
	output_file = gfopen(argv[3], "w");
	for(int i_run = 0; i_run < n_runs; i_run++){

		// Use vectors rather than linked lists for their built-in functions and multi-dimensionality
		// Vectors will store the ABSOLUTE COORD (MT array index + coord of MT edge) of relevant items 
		std::vector< std::vector<int> > bound_list,
										unbound_list;
		// Populates vectors from initial conditions 
		for(int j_mt = 0; j_mt < n_microtubules; j_mt++){
			// Resets the MT array to what was read from the config file 
			// ****MAKE CLEAR_ARRAY FUNCTION TO ENABLE MULTIPLE RUNS***
			memcpy(&mt_array[j_mt], &mt_array_initial[j_mt], sizeof(microtubule));
			std::vector<int> temp_bound, 
							 temp_unbound;
			for(int k_site = 0; k_site < length_of_microtubule; k_site++){
				if(mt_array[j_mt].track[k_site].occupancy[0] == 0){
					temp_unbound.push_back(k_site + mt_array[j_mt].coord[0]);
				}
				else if(mt_array[j_mt].track[k_site].occupancy[0] == 2){
					temp_bound.push_back(k_site + mt_array[j_mt].coord[0]);
				}
			}
			unbound_list.push_back(temp_unbound);
			bound_list.push_back(temp_bound);
			temp_unbound.clear();
			temp_bound.clear();
		}

		// Main kMC loop 
		for(int i_step = 0; i_step < n_steps; i_step++){
			
			// Initiate vectors to keep track of statistics for each individual MT		
			std::vector<int> n_to_bind(n_microtubules),
                             n_to_unbind(n_microtubules),
                             n_to_switch(n_microtubules),
                             n_to_move(n_microtubules),
							 n_tot(n_microtubules);
            std::vector<double> n_avg(n_microtubules);

			int n_max = 0;			// Maximum number of kMC events for any one MT in a timestep; needed for mem alloc
			int n_tot_step = 0;		// Combined number of ALL kMC events on ALL MTs in a timestep; needed for mem alloc
			// Calculate expected number of events in this particular timestep for each MT
			for(int j_mt = 0; j_mt < n_microtubules; j_mt++){	
				// Calculate average number of binding events per timestep, then use it to sample Poisson for expected number of events
				n_avg[j_mt] = p_bind*(length_of_microtubule - mt_array[j_mt].n_bound[0]);
				n_to_bind[j_mt] = gsl_ran_poisson(rng, n_avg[j_mt]);
				// Sample binomial distribution for the rest of the events (self-explanatory)
				n_to_unbind[j_mt] = gsl_ran_binomial(rng, p_unbind, mt_array[j_mt].n_bound[0]);
				n_to_switch[j_mt] = gsl_ran_binomial(rng, p_switch, mt_array[j_mt].n_bound[0]);
				n_to_move[j_mt] = gsl_ran_binomial(rng, p_move, mt_array[j_mt].n_bound[0]);
				// Calculates the total number of events expected in this timestep for each MT
				n_tot[j_mt] = n_to_bind[j_mt] + n_to_unbind[j_mt] + n_to_switch[j_mt] + n_to_move[j_mt];
				// Need to know the largest number of total expected events on any one MT to allocate kmc_array later
				if(n_tot[j_mt] > n_max){
					n_max = n_tot[j_mt];
				}
				// Need to know number of total expected events for ALL Mts combined to allocate mt_list later
				n_tot_step += n_tot[j_mt];
			}
			// The 1D array 'mt_list' acts as a master list of all kMC events expected in a timestep; 
			// each entry will lead to one kMC event on the MT which the entry's index corresponds to
			int mt_list[n_tot_step];
			int list_start = 0;
			// Populate mt_list according to above statistics; the index of each MT appears n_tot[j_mt] times	
			for(int j_mt = 0; j_mt < n_microtubules; j_mt++){
				for(int i_list = list_start; i_list < (n_tot[j_mt] + list_start); i_list++){
					mt_list[i_list] = j_mt;
				}
				list_start += n_tot[j_mt];
			}
			// Only attempt to shuffle mt_list if it exists
			if(n_tot_step > 0){
				gsl_ran_shuffle(rng, mt_list, n_tot_step, sizeof(int));
			}
			// Similar to mt_list, but kmc_array stores the exact type of kmc event that will occur for each MT
			int kmc_array[n_microtubules][n_max];	
			// Populates and shuffles the kmc_list of each MT, i.e. kmc_array[j_mt], according to above statistics
			for(int j_mt = 0; j_mt < n_microtubules; j_mt++){	
				for(int i_list = 0; i_list < n_to_bind[j_mt]; i_list++){
					kmc_array[j_mt][i_list] = 0;				// "0" means the kMC event corresponds to binding
				}
				for(int i_list = n_to_bind[j_mt]; i_list < (n_to_bind[j_mt] + n_to_unbind[j_mt]); i_list++){
					kmc_array[j_mt][i_list] = 1;				// "1" means the kMC event corresponds to unbinding
				}
				for(int i_list = (n_to_bind[j_mt] + n_to_unbind[j_mt]); i_list < (n_tot[j_mt] - n_to_move[j_mt]); i_list++){
					kmc_array[j_mt][i_list] = 2;				// "2" means the kMC event corresponds to switching
				}
				for(int i_list = (n_tot[j_mt] - n_to_move[j_mt]); i_list < n_tot[j_mt]; i_list++){
					kmc_array[j_mt][i_list] = 3;				// "3" means the kMC event corresponds to moving
				}
				// Only attempt to shuffle kmc_array[j_mt] if it exists
				if(n_tot[j_mt] > 0){
					gsl_ran_shuffle(rng, kmc_array[j_mt], n_tot[j_mt], sizeof(int));
				}
			}

			// Initializes the entry of each list to 0, i.e. makes sure we start at the beginning of each list
			int mt_list_entry = 0;
			// Each MT has its own kmc_list, so multiple entries need to be kept track of; these are stored in kmc_list_entries
			int kmc_list_entries[n_microtubules];
			for(int j_mt = 0; j_mt < n_microtubules; j_mt++){
				kmc_list_entries[j_mt] = 0;
			}

			// Keeps running until the expected number of kMC events occur
			while(mt_list_entry < n_tot_step){

				int mt_index = mt_list[mt_list_entry];

				int kmc_list_entry = kmc_list_entries[mt_index];
				int kmc_index = kmc_array[mt_index][kmc_list_entry];
				switch(kmc_index){
					case 0:
						motors_bind(&parameters, mt_array, bound_list, unbound_list, mt_index, rng);
						break;
					case 1:
						motors_unbind(&parameters, mt_array, bound_list, unbound_list, mt_index, rng);
						break;
					case 2:
						motors_switch(&parameters, mt_array, bound_list, unbound_list, mt_index, rng);
						break;
					case 3:
						motors_move(&parameters, mt_array, bound_list, unbound_list, mt_index, rng);
						break;
				}
				motors_boundaries(&parameters, mt_array, bound_list, unbound_list, rng);

				mt_list_entry++;
				kmc_list_entries[mt_index]++;
			}
//			print_microtubules(&parameters, mt_array);
//			printf("\n");

			// Gives updates on equilibration process (every 5%)
			if(i_step < data_threshold){
				if(i_step%equil_milestone == 0){
					printf("Equilibration is %i percent complete. (step number %i)\n", (int)(i_step/equil_milestone)*5, i_step);
				}
			}
			// Starts data collection at threshold
			else if(i_step >= data_threshold){
				int delta = i_step - data_threshold;
				if(delta%pickup_time == 0){
					printf("\nRun %d, step %d:\n", (i_run+1), (i_step));
					print_microtubules(&parameters, mt_array);
					output_data(&parameters, mt_array, output_file);	
					fflush(stdout);
				}
			}
		}
	}
	fclose(output_file);

	finish = clock();
	duration = (double)(finish-start)/CLOCKS_PER_SEC;

	stream = fopen("time_main.dat","w");
	fprintf(stream, "Time to execute main code: %f seconds\n", duration);
	fclose(stream);

	return 0;
}
